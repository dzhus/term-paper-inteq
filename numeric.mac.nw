@

Данная программа реализует численный способ решения уравнения
\eqref{eq:ieqgen}, описанный в разделе \ref{sec:numeric}.

Общая структура программы такова:
<<*>>=
<<ввод исходных данных>>
<<вычисление шага и построение сетки>>
<<построение системы линейных уравнений>>
<<решение системы>>

@ Для работы программы необходимо ввести исходные данные,
соответствующие постановке задачи (см. \ref{sec:problem})
<<ввод исходных данных>>=
<<отрезок интегрирования>>
<<параметр $\lambda$>>
<<количество точек в сетке>>
<<ядро интегрального уравнения>>
<<неоднородность в правой части>>

<<построение системы линейных уравнений>>=
<<построение матрицы $B$>>
<<построение векторов $\vec{\phi}$ и $\vec{f}$>>
<<построение левой части матричного уравнения>>

<<решение системы>>=
<<нахождение решения>>
<<запись решения в файл>>

<<отрезок интегрирования>>=
a: 0;
b: 1;

<<количество точек в сетке>>=
k: 10;

<<параметр $\lambda$>>=
l: 2;

<<ядро интегрального уравнения>>=
K(x,t) := if (0<=x) and (x<=t) then
                                 cosh(x)*cosh(t-1)/sinh(1)
                               else
                                 cosh(t)*cosh(x-1)/sinh(1);

<<неоднородность в правой части>>=
f(x) := cosh(x);

<<вычисление шага и построение сетки>>=
h: (b-a)/k;
grid: makelist(a+i*h, i, 0, k);

<<построение матрицы $B$>>=
B: genmatrix(lambda([i, j], h * K(grid[i], grid[j]) * (if (j=1 or j=k+1) then 1/2 else 1)),
             k+1, k+1, 1, 1);

<<построение векторов $\vec{\phi}$ и $\vec{f}$>>=
variables: makelist(x[i], i, 1, k+1);
f_list: map(f, grid);

<<построение левой части матричного уравнения>>=
C: (ident(k+1)-l*B).variables;
equations: makelist((C[i][1]=f_list[i]), i, 1, k+1);

<<нахождение решения>>=
solution: solve(equations, variables);

@ Вызов [[float]] выполняется в самом конце для обеспечения
минимальной потери точности

<<запись решения в файл>>=
write_data(float(makelist([grid[i], rhs(solution[1][i])], i, 1, k+1)), "out.mac");