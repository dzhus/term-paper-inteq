% -*- mode: noweb; noweb-code-mode: maxima-mode -*-
@

Данная программа реализует описанный выше приближённый способ решения
уравнения \eqref{eq:ieqgen} на языке среды \emph{символьных}
вычислений \program{Maxima}.

Общая структура программы такова:
<<*>>=
<<ввод исходных данных>>
<<вычисление шага и построение сетки>>
<<построение и решение системы>>
<<запись решения в файл>>

@ Для работы программы необходимо ввести исходные данные,
соответствующие постановке задачи (см. \ref{sec:problem}), а также
установить требуемое число точек в сетке $\Xi_n$.
<<ввод исходных данных>>=
<<отрезок интегрирования>>
<<параметр $\lambda$>>
<<ядро интегрального уравнения>>
<<неоднородность в правой части>>
<<количество точек в сетке>>
<<отрезок интегрирования>>=
a: 0;
b: 1;
<<параметр $\lambda$>>=
l: 2;
<<ядро интегрального уравнения>>=
K(x,t) := if (0<=x) and (x<=t) then
                                 cosh(x)*cosh(t-1)/sinh(1)
                               else
                                 cosh(t)*cosh(x-1)/sinh(1);
<<неоднородность в правой части>>=
f(x) := cosh(x);
<<количество точек в сетке>>=
n: 10;

<<вычисление шага и построение сетки>>=
h: (b-a)/(n-1);
tau: makelist(a+i*h, i, 0, n-1);

@
После определения всех необходимых данных строится система линейных
уравнений \eqref{eq:matrix-equation}. Через $C$ обозначено
произведение матрицы $(E_n-\lambda B)$ и вектора неизвестных
$\vec{\phi}$. [[equations]] представляет собой набор рассматриваемых
уравнений в \emph{символьном} виде.
<<построение и решение системы>>=
<<построение матрицы $B$>>
<<построение вектора $\vec{f}$ — [[f_vector]]>>
<<построение вектора неизвестных $\vec{\phi}$ — [[phi_vector]]>>
C: (ident(n)-l*B).phi_vector;
equations: makelist((C[i][1]=f_vector[i]), i, 1, n);
<<решение системы>>
@
Элементы $B$ вычисляются согласно \eqref{eq:B-matrix-element}:
<<построение матрицы $B$>>=
B: genmatrix(lambda([i, j], h * K(tau[i], tau[j])
                              * (if (j=1 or j=n) then 1/2 else 1)),
             n, n, 1, 1);
@
Вектор $\vec{f}$ состоит из значений функции $f$ в точках $\tau_i$
выбранной сетки:
<<построение вектора $\vec{f}$ — [[f_vector]]>>=
f_vector: map(f, tau);
@
Для построения уравнений потребуется \emph{символьный} вектор неизвестных
переменных $\vec{\phi}$, относительно которых эта система будет
решаться:
<<построение вектора неизвестных $\vec{\phi}$ — [[phi_vector]]>>=
phi_vector: makelist(x[i], i, 1, n);
@
Решение системы относительно $\vec{\phi}$ выполняется
функцией [[solve]]:
<<решение системы>>=
solution: solve(float(equations), phi_vector);

@ 
На данном этапе решение [[solution]] представляет собой символьное
выражение. Для анализа решения необходимо получить его значение в
численном виде функцией [[float]]. Вызов [[float]] на готовом решении
позволяет избежать значительных потерь точности, связанных с
многократным выполнением операций деления при решении системы. После
этого производится запись точек $(\tau_i, \phi(\tau_i))$ в файл для
последующей обработки.
<<запись решения в файл>>=
write_data((makelist([tau[i], rhs(solution[1][i])],
                          i, 1, n)),
           "out.mac");