% -*- mode: noweb; noweb-code-mode: maxima-mode -*-
@

Данная программа реализует описанный выше приближённый способ решения
уравнения \eqref{eq:ieqgen} на языке среды \emph{символьных}
вычислений \program{Maxima}.

Общая структура программы такова:
<<*>>=
<<ввод исходных данных>>
<<вычисление шага и построение сетки>>
<<построение системы линейных уравнений>>
<<решение системы>>

@ Для работы программы необходимо ввести исходные данные,
соответствующие постановке задачи (см. \ref{sec:problem}), а также
установить требуемое число точек в сетке $\Xi_n$.
<<ввод исходных данных>>=
<<отрезок интегрирования>>
<<параметр $\lambda$>>
<<ядро интегрального уравнения>>
<<неоднородность в правой части>>
<<количество точек в сетке>>
<<отрезок интегрирования>>=
a: 0;
b: 1;
<<параметр $\lambda$>>=
l: 2;
<<ядро интегрального уравнения>>=
K(x,t) := if (0<=x) and (x<=t) then
                                 cosh(x)*cosh(t-1)/sinh(1)
                               else
                                 cosh(t)*cosh(x-1)/sinh(1);
<<неоднородность в правой части>>=
f(x) := cosh(x);
<<количество точек в сетке>>=
n: 10;

<<вычисление шага и построение сетки>>=
h: (b-a)/(n-1);
grid: makelist(a+i*h, i, 0, n-1);

@
После определения всех необходимых данных строится система линейных
уравнений \eqref{eq:matrix-equation}. Через $C$ обозначено
произведение матрицы $(E_n-\lambda B)$ на вектор неизвестных
$\vec{\phi}$:
<<построение системы линейных уравнений>>=
<<построение матрицы $B$>>
<<построение вектора $\vec{f}$>>
<<построение вектора неизвестных $\vec{\phi}$>>                                
C: (ident(n)-l*B).variables;
equations: makelist((C[i][1]=f_list[i]), i, 1, n);
@
Элементы $B$ вычисляются согласно \eqref{eq:B-matrix-element}:
<<построение матрицы $B$>>=
B: genmatrix(lambda([i, j], h * K(grid[i], grid[j])
                              * (if (j=1 or j=n) then 1/2 else 1)),
             n, n, 1, 1);
@
Вектор $\vec{f}$ состоит из значений функции $f$ в точках $\tau_i$
выбранной сетки:
<<построение вектора $\vec{f}$>>=
f_list: map(f, grid);
@
Для построения уравнений потребуется (символьный) вектор неизвестных
переменных $\vec{\phi}$, относительно которых эта система будет
решаться:
<<построение вектора неизвестных $\vec{\phi}$>>=
variables: makelist(x[i], i, 1, n);

@ 
Остаётся решить полученную систему и сохранить результаты:
<<решение системы>>=
<<нахождение решения>>
<<запись решения в файл>>
@
Решение системы относительно $\vec{\phi}$ выполняется
функцией [[solve]]:
<<нахождение решения>>=
solution: solve(equations, variables);
@ 
На данном этапе решение [[solution]] представляет собой символьное
выражение. Для анализа решения необходимо получить его значение в
численном виде функцией [[float]]. Вызов [[float]] на готовом решении
позволяет избежать значительных потерь точности, связанных с
многократным выполнением операций деления при решении системы. После
этого производится запись точек $(\tau_i, \phi(\tau_i))$ в файл для
последующей обработки.
<<запись решения в файл>>=
write_data(float(makelist([grid[i], rhs(solution[1][i])],
                          i, 1, n)),
           "out.mac");