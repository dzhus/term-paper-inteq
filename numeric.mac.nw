% -*- mode: noweb; noweb-code-mode: maxima-mode -*-
@

Данная программа реализует численный способ решения уравнения
\eqref{eq:ieqgen}, описанный в разделе \ref{sec:numeric}.

Общая структура программы такова:
<<*>>=
<<ввод исходных данных>>
<<вычисление шага и построение сетки>>
<<построение системы линейных уравнений>>
<<решение системы>>
@
Для работы программы необходимо ввести исходные данные,
соответствующие постановке задачи (см. \ref{sec:problem})
<<ввод исходных данных>>=
<<отрезок интегрирования>>
<<параметр $\lambda$>>
<<количество точек в сетке>>
<<ядро интегрального уравнения>>
<<неоднородность в правой части>>
<<отрезок интегрирования>>=
a: 0;
b: 1;
<<количество точек в сетке>>=
k: 10;
<<параметр $\lambda$>>=
l: 2;
<<ядро интегрального уравнения>>=
K(x,t) := if (0<=x) and (x<=t) then
                                 cosh(x)*cosh(t-1)/sinh(1)
                               else
                                 cosh(t)*cosh(x-1)/sinh(1);
<<неоднородность в правой части>>=
f(x) := cosh(x);

<<вычисление шага и построение сетки>>=
h: (b-a)/k;
grid: makelist(a+i*h, i, 0, k);

@
После определения всех необходимых данных строится система линейных
уравнений \eqref{eq:matrix-equation}. Через $C$ обозначено
произведение матрицы $(E_n-\lambda B)$ на вектор неизвестных
$\vec{\phi}$:
<<построение системы линейных уравнений>>=
<<построение матрицы $B$>>
<<построение вектора $\vec{f}$>>
<<построение вектора неизвестных $\vec{\phi}$>>                                
C: (ident(k+1)-l*B).variables;
equations: makelist((C[i][1]=f_list[i]), i, 1, k+1);
@
Элементы $B$ вычисляются согласно \eqref{eq:B-matrix-element}:
<<построение матрицы $B$>>=
B: genmatrix(lambda([i, j], h * K(grid[i], grid[j])
                              * (if (j=1 or j=k+1) then 1/2 else 1)),
             k+1, k+1, 1, 1);
<<построение вектора $\vec{f}$>>=
f_list: map(f, grid);
@
Для построения уравнений потребуется (символьный) вектор неизвестных
переменных $\vec{\phi}$, относительно которых эта система будет
решаться:
<<построение вектора неизвестных $\vec{\phi}$>>=
variables: makelist(x[i], i, 1, k+1);

<<решение системы>>=
<<нахождение решения>>
<<запись решения в файл>>
@
Решение построенной системы относительно $\vec{\phi}$ выполняется
функцией [[solve]]:
<<нахождение решения>>=
solution: solve(equations, variables)$
@
На данном этапе решение [[solution]] представляет собой символьное
выражение. Для анализа решения необходимо получить его значение в
численном виде функцией [[float]]. Вызов [[float]] на готовом решении
позволяет избежать значительных потерь точности, связанных с
многократным выполнением операций деления при решении системы.
<<запись решения в файл>>=
write_data(float(makelist([grid[i], rhs(solution[1][i])], i, 1, k+1)), "out.mac");