% -*- mode: noweb; noweb-code-mode: maxima-mode -*-
@

Следующая программа написана на языке среды символьных вычислений
\program{Maxima} и реализует построение решения $\phi(x)$ как
частичную сумму ряда \eqref{eq:gs-solution}, после чего записывает
график полученной функции в файл.

Использование \program{Maxima} обусловлено возможностью реализовать
алгоритм на уровне абстракции, весьма близком к математическому
описанию из раздела \ref{sec:gs-application}.

Программа не содержит большого числа операций:
<<*>>=
<<установка исходных данных>>
<<построение частичной суммы ряда>>
<<запись графика полученного решения в файл>>

@ На данном этапе устанавливаются данные по условию значения пределов
интегрирования и параметра $\lambda$, вид функции $f(x)$:
<<установка исходных данных>>=
<<отрезок интегрирования>>
<<параметр $\lambda$>>
<<неоднородность в правой части>>
<<число членов в частичной сумме ряда>>
<<отрезок интегрирования>>=
a: 0;
b: 1;
<<параметр $\lambda$>>=
lambda: 2;
<<неоднородность в правой части>>=
f(x) := cosh(x);
<<число членов в частичной сумме ряда>>=
n: 5;

@ Для построения ряда необходимо установить вид собственных функций,
характеристических значений, определить коэффициенты $f_k$. После
этого построение решения выполняется согласно общей формуле
\eqref{eq:gs-solution-form} в два шага — сначала строится часть с
суммой, после чего сумма умножается на $\lambda$ и складывается с
неоднородностью уравнения, что и даёт приближённое решение.
<<построение частичной суммы ряда>>=
<<установка систем $\psi_k(x)$ и $\lambda_k$>>
<<определение значений $f_k$>>                                              
series: sum(f_k(k) * eigenfun(k) / (eigenval(k) - lambda), k, 0, n-1);
solution(y) := f(y) + lambda * at(series, x=y);

@ Функции [[eigenfun]] и [[eigenval]] определены согласно
\eqref{eq:eigfuns} и \eqref{eq:eigvals} и возвращают выражение для
определяемой параметром [[k]] собственной функции $\psi_k(x)$ или
характеристического числа $\lambda_k$, соответственно.
<<установка систем $\psi_k(x)$ и $\lambda_k$>>=
eigenfun(k) := if (k=0) then 1 else sqrt(2) * cos(%pi*k*x);
eigenval(k) := if (k=0) then 1 else 1 + (%pi*k)^2;

@ Коэффициент $f_k$ возвращается функцией [[f_k]] по формуле $f_k =
\int_a^b{f(x)\psi_k(x)\,dx}$
<<определение значений $f_k$>>=
f_k(k) := integrate(f(x) * eigenfun(k), x, a, b);

<<запись графика полученного решения в файл>>=
plot2d([solution(y)], [y, a, b], [nticks, 1], [adapt_depth, 1],
       [gnuplot_preamble, "set table \"series.mac.out\""]);
