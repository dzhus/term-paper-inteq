% -*- mode: noweb; noweb-code-mode: octave-mode -*-
@

Представленная программа является реализацией приближённого метода
решения интегрального уравнения в среде \program{GNU Octave}.

Общая структура программы такова:
<<*>>=
<<ввод исходных данных>>
<<вычисление шага и построение сетки>>
<<построение и решение системы>>
<<запись решения в файл>>
@
Для работы программы необходимо установить исходные данные,
соответствующие постановке задачи (см. \ref{sec:problem}), а также
установить требуемое число точек в сетке $\Xi_n$.
<<ввод исходных данных>>=
<<отрезок интегрирования>>
<<параметр $\lambda$>>
<<ядро интегрального уравнения>>
<<неоднородность в правой части>>
<<количество точек в сетке>>
<<отрезок интегрирования>>=
a = 0
b = 1
<<параметр $\lambda$>>=
lambda = 2
<<ядро интегрального уравнения>>=
function K = K (x, t)
  if ((0 <= x) & (x <= t))
    K = cosh(x)*cosh(t-1)/sinh(1);
  else
    K = cosh(t)*cosh(x-1)/sinh(1);
  endif
endfunction
<<неоднородность в правой части>>=
function f = f (x)
  f = cosh(x);
endfunction

@ Требуемое количество точек в сетке вводится с клавиатуры
<<количество точек в сетке>>=
n = input("n=? ")

@ Конструкция [[a : h : b]] возвращает сетку с шагом [[h]] на отрезке
от [[a]] до [[b]]
<<вычисление шага и построение сетки>>=
h = (b - a) / (n - 1)
tau = a : h : b;

<<построение и решение системы>>=
<<построение матрицы $B$>>
<<построение вектора $\vec{f}$>>
<<решение системы>>
@ В \program{Octave} матрицы динамически изменяют свои размеры при
присваивании нового значения несуществующему элементу матрицы.
Поскольку конечные размеры матрицы $B$ известны ($n×n$), в целях
оптимизации выгоднее сразу проинициализировать её нулями при помощи
[[zeros]], чтобы сэкономить на операциях выделения дополнительной
памяти.
<<построение матрицы $B$>>=
B = zeros(n);
for i = 1:n
  for j = 1:n
    if ((j == 1) | (j == n))
      factor = 1/2;
    else
      factor = 1;
    endif
    B(i, j) = h * factor * K(tau(i), tau(j));
  endfor
endfor
<<построение вектора $\vec{f}$>>=
f_vector = zeros(n, 1);
for i = 1:n
  f_vector(i) = f(tau(i));
endfor
@ Вектор $\vec{\phi}$ находится из уравнения
\eqref{eq:matrix-equation} как $\vec{\phi} = \left [ E_n-\lambda B
\right ]^{-1}\vec{f}$. Функция [[eye]] возвращает единичную матрицу
заданного размера:
<<решение системы>>=
phi_values = (eye(n) - lambda*B) \ f_vector;

<<запись решения в файл>>=
points = [tau', phi_values]
save (sprintf("numeric-%d.oct.out", n), "points")
