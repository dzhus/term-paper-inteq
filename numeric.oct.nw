% -*- mode: noweb; noweb-code-mode: octave-mode -*-
@

Представленная программа является реализацией приближённого метода
решения интегрального уравнения в среде \emph{численных} вычислений
\program{GNU Octave}.

Структура программы такая же, как у реализации на Maxima:
<<*>>=
<<ввод исходных данных>>
<<вычисление шага и построение сетки>>
<<построение и решение системы>>
<<запись решения в файл>>

@ Исходные данные вводятся аналогично:
<<ввод исходных данных>>=
a = 0
b = 1
lambda = 2
<<ядро интегрального уравнения>>
<<неоднородность в правой части>>
<<количество точек в сетке>>
<<ядро интегрального уравнения>>=
function K = K (x, t)
  if ((0 <= x) & (x <= t))
    K = cosh(x)*cosh(t-1)/sinh(1);
  else
    K = cosh(t)*cosh(x-1)/sinh(1);
  endif
endfunction
<<неоднородность в правой части>>=
function f = f (x)
  f = cosh(x);
endfunction
<<количество точек в сетке>>=
n = 100

<<вычисление шага и построение сетки>>=
h = (b - a) / (n - 1)
grid = a : h : b;

@
<<построение и решение системы>>=
<<построение матрицы $B$>>
<<построение вектора $\vec{f}$>>
<<решение системы>>
@
В \program{Octave} матрицы могут динамически изменять свои размеры
при присваивании нового значения несуществующему элементу матрицы.
Поскольку конечные размеры матрицы $B$ известны ($n×n$), в целях
оптимизации выгоднее сразу проинициализировать её нулями при помощи
[[zeros]], чтобы сэкономить на операциях выделения дополнительной
памяти.
<<построение матрицы $B$>>=
B = zeros(n);
for i = 1:n
  for j = 1:n
    if ((j == 0) | (j == n))
      factor = 1/2;
    else
      factor = 1;
    endif
    B(i, j) = h * factor * K(grid(i), grid(j));
  endfor
endfor
<<построение вектора $\vec{f}$>>=
f_vector = zeros(n, 1);
for i = 1:n
  f_vector(i) = f(grid(i));
endfor
@ \program{GNU Octave} — численная среда, поэтому в отличие от
\program{Maxima} нам не требуется создавать \emph{символьный} вектор
неизвестных $\vec{\phi}$, поскольку можно сразу найти его численно из
уравнения \eqref{eq:matrix-equation} как $\vec{\phi} = \left [
  E_n-\lambda B \right ]^{-1}\vec{f}$:
<<решение системы>>=
phi_values = (eye(n) - lambda*B) \ f_vector;

<<запись решения в файл>>=
points = [grid', phi_values]
save out.oct points
